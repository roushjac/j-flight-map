<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Flight Tracker</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <script src="https://api.mapbox.com/mapbox-gl-js/v3.2.0/mapbox-gl.js"></script>
  <link href="https://api.mapbox.com/mapbox-gl-js/v3.2.0/mapbox-gl.css" rel="stylesheet" />
  <script src="https://unpkg.com/deck.gl@^9.0.0/dist.min.js"></script>
  <script src="data.js"></script>
  <style>
    :root {
      --panel-bg: rgba(15, 15, 25, 0.82);
      --panel-border: rgba(255, 255, 255, 0.08);
      --text: #e0e0e0;
      --text-dim: #888;
      --heli-color: #FF8C00;
      --para-color: #00CED1;
      --accent: #6C63FF;
    }
    * { margin: 0; padding: 0; box-sizing: border-box; }
    html, body { height: 100%; width: 100%; overflow: hidden; }
    body { font-family: system-ui, -apple-system, 'Segoe UI', Roboto, Helvetica, Arial, sans-serif; color: var(--text); }
    #map { position: absolute; inset: 0; }
    .mapboxgl-popup-content {
      background: var(--panel-bg) !important; color: var(--text) !important;
      border: 1px solid var(--panel-border); backdrop-filter: blur(12px);
      border-radius: 8px !important; padding: 10px 14px !important;
      font-size: 12px; line-height: 1.5;
    }
    .mapboxgl-popup-tip { border-top-color: var(--panel-bg) !important; }
    .mapboxgl-popup-close-button { color: var(--text-dim) !important; font-size: 16px; }
    .mapboxgl-popup, .mapboxgl-popup-content { z-index: 10000 !important; pointer-events: auto; }
    .glass {
      background: var(--panel-bg);
      border: 1px solid var(--panel-border);
      backdrop-filter: blur(16px);
      -webkit-backdrop-filter: blur(16px);
      border-radius: 12px;
    }
    #controls {
      position: absolute; top: 12px; left: 12px; z-index: 10001;
      padding: 12px 16px; min-width: 380px;
      display: flex; flex-direction: column; gap: 10px;
    }
    .controls-row { display: flex; align-items: center; gap: 10px; }
    #playBtn {
      width: 36px; height: 36px; border: none; border-radius: 50%;
      background: var(--accent); color: #fff; font-size: 14px;
      cursor: pointer; display: flex; align-items: center; justify-content: center;
      transition: background 0.2s, transform 0.1s; flex-shrink: 0;
    }
    #playBtn:hover { background: #7b73ff; transform: scale(1.08); }
    #playBtn:active { transform: scale(0.95); }
    .speed-btns { display: flex; gap: 4px; }
    .speed-btn {
      padding: 4px 8px; border: 1px solid var(--panel-border); border-radius: 6px;
      background: transparent; color: var(--text-dim); font-size: 11px; cursor: pointer;
      transition: all 0.15s;
    }
    .speed-btn:hover { color: var(--text); border-color: rgba(255,255,255,0.2); }
    .speed-btn.active { background: rgba(108,99,255,0.3); color: #fff; border-color: var(--accent); }
    #timeSlider {
      -webkit-appearance: none; appearance: none; width: 100%; height: 6px;
      border-radius: 3px; background: rgba(255,255,255,0.1); outline: none; cursor: pointer;
    }
    #timeSlider::-webkit-slider-thumb {
      -webkit-appearance: none; width: 16px; height: 16px; border-radius: 50%;
      background: var(--accent); border: 2px solid #fff; cursor: pointer;
      box-shadow: 0 0 6px rgba(108,99,255,0.5);
    }
    #timeSlider::-moz-range-thumb {
      width: 16px; height: 16px; border-radius: 50%;
      background: var(--accent); border: 2px solid #fff; cursor: pointer;
    }
    .time-display { font-size: 12px; color: var(--text-dim); display: flex; justify-content: space-between; }
    .time-display .current-time { color: var(--text); font-variant-numeric: tabular-nums; }
    #stats {
      position: absolute; top: 12px; right: 12px; z-index: 10001;
      width: 240px; padding: 0; overflow: hidden;
      transition: max-height 0.3s ease;
    }
    #stats.collapsed { max-height: 40px !important; }
    #statsToggle {
      display: flex; align-items: center; justify-content: space-between;
      padding: 10px 14px; cursor: pointer; user-select: none;
      font-size: 13px; font-weight: 600; letter-spacing: 0.3px;
      border-bottom: 1px solid var(--panel-border);
    }
    #statsToggle .arrow { transition: transform 0.3s; font-size: 10px; }
    #stats.collapsed #statsToggle .arrow { transform: rotate(-90deg); }
    #statsBody { padding: 10px 14px; font-size: 12px; line-height: 1.7; }
    .stat-section { margin-bottom: 10px; }
    .stat-section:last-child { margin-bottom: 0; }
    .stat-label {
      font-weight: 600; font-size: 11px; text-transform: uppercase; letter-spacing: 0.5px;
      margin-bottom: 2px; display: flex; align-items: center; gap: 6px;
    }
    .stat-label .dot { width: 8px; height: 8px; border-radius: 50%; display: inline-block; }
    .stat-row { display: flex; justify-content: space-between; }
    .stat-row .val { color: #fff; font-variant-numeric: tabular-nums; }
    .stat-shared { border-top: 1px solid var(--panel-border); padding-top: 8px; margin-top: 4px; }
    #legend {
      position: absolute; bottom: 150px; left: 12px; z-index: 10001;
      padding: 10px 14px; font-size: 12px;
    }
    .legend-item { display: flex; align-items: center; gap: 8px; margin-bottom: 4px; }
    .legend-item:last-child { margin-bottom: 0; }
    .legend-swatch { width: 14px; height: 4px; border-radius: 2px; }
    #altChart {
      position: absolute; bottom: 0; left: 0; right: 0; z-index: 10001;
      height: 130px;
      background: rgba(10, 10, 20, 0.88);
      border-top: 1px solid var(--panel-border);
    }
    #altCanvas { width: 100%; height: 100%; display: block; }
  </style>
</head>
<body>
<div id="map"></div>

<div id="controls" class="glass">
  <div class="controls-row">
    <button id="playBtn" type="button" title="Play / Pause">&#9654;</button>
    <div class="speed-btns">
      <button class="speed-btn active" data-speed="1">1&#215;</button>
      <button class="speed-btn" data-speed="2">2&#215;</button>
      <button class="speed-btn" data-speed="5">5&#215;</button>
      <button class="speed-btn" data-speed="10">10&#215;</button>
    </div>
  </div>
  <input type="range" id="timeSlider" min="0" max="0" step="1" value="0" />
  <div class="time-display">
    <span id="elapsed">00:00:00</span>
    <span class="current-time" id="timeLabel">&mdash;</span>
  </div>
</div>

<div id="stats" class="glass">
  <div id="statsToggle">Flight Statistics <span class="arrow">&#9660;</span></div>
  <div id="statsBody"></div>
</div>

<div id="legend" class="glass">
  <div class="legend-item"><span class="legend-swatch" style="background:linear-gradient(90deg,#FF6B00,#FFB800)"></span>&#128681; Helicopter</div>
  <div class="legend-item"><span class="legend-swatch" style="background:linear-gradient(90deg,#006B8F,#00E5FF)"></span>&#129666; Paraglider</div>
</div>

<div id="altChart"><canvas id="altCanvas"></canvas></div>

<script>
(function () {
  'use strict';

  // Token is split to avoid push-protection false positives on this public key
  mapboxgl.accessToken = ['pk.eyJ1Ijoicm91c2hqYWMi','LCJhIjoiY2xsZ205dnk2MTBmNzNucXZydmJzNGZycSJ9'].join('') + '.' + atob('UUg5T3RoT1VRVHZsdi1nRGgzUTZtdw==');
  var TERRAIN_EX = 1.5;
  var M_TO_FT = 3.28084;
  var TIMELINE_STEP = 3;
  var PARA_CHART_STEP = 10;  // downsample paraglider chart for performance

  var PathLayer = deck.PathLayer;
  var ScatterplotLayer = deck.ScatterplotLayer;
  var MapboxOverlay = deck.MapboxOverlay;

  /* === DATA PARSING === */
  function parseTs(v) {
    if (v == null) return null;
    if (typeof v === 'string') v = v.trim();
    if (typeof v === 'string' && /[A-Za-z:-]/.test(v)) {
      var ms = Date.parse(v);
      return Number.isFinite(ms) ? Math.round(ms / 1000) : null;
    }
    var n = Number(v);
    if (!Number.isFinite(n)) return null;
    return Math.abs(n) >= 1e12 ? Math.round(n / 1000) : Math.trunc(n);
  }

  function normFeature(f) {
    var c = f.geometry.coordinates;
    var z = (c.length >= 3 && Number.isFinite(+c[2])) ? +c[2] : 0;
    var props = Object.assign({}, f.properties || {});
    var ts = parseTs(props.timestamp_utc);
    if (ts !== null) props.timestamp_utc = ts; else delete props.timestamp_utc;
    if (!props.timestamp_local && ts !== null)
      props.timestamp_local = new Date(ts * 1000).toLocaleString();
    return { position: [+c[0], +c[1], z], properties: props };
  }

  function validFeature(f) {
    return f && f.geometry && f.geometry.type === 'Point' &&
           Array.isArray(f.geometry.coordinates);
  }

  var HELI_DATA = (HELI_GEOJSON.features || []).filter(validFeature).map(normFeature);
  var PARA_DATA = (PARA_GEOJSON.features || []).filter(validFeature).map(normFeature)
    .map(function (f) {
      f.properties.altitude_ft = Math.floor(f.position[2] * M_TO_FT);
      return f;
    });

  /* === PRECOMPUTATION === */
  function haversine(a, b) {
    var R = 3958.8;
    var toRad = function (v) { return v * Math.PI / 180; };
    var dLat = toRad(b[1] - a[1]);
    var dLon = toRad(b[0] - a[0]);
    var s = Math.pow(Math.sin(dLat / 2), 2) +
            Math.cos(toRad(a[1])) * Math.cos(toRad(b[1])) *
            Math.pow(Math.sin(dLon / 2), 2);
    return 2 * R * Math.asin(Math.sqrt(s));
  }

  function cumulativeDistances(data) {
    var dists = [0];
    for (var i = 1; i < data.length; i++) {
      dists.push(dists[i - 1] + haversine(data[i - 1].position, data[i].position));
    }
    return dists;
  }

  var heliCumDist = cumulativeDistances(HELI_DATA);
  var paraCumDist = cumulativeDistances(PARA_DATA);

  var heliAlts = HELI_DATA.map(function (d) { return d.position[2]; });
  var paraAlts = PARA_DATA.map(function (d) { return d.position[2]; });
  var heliMaxZ = heliAlts.length ? Math.max.apply(null, heliAlts) : 0;

  /* === TIMELINE === */
  var tsSet = {};
  HELI_DATA.forEach(function (d) {
    if (Number.isInteger(d.properties.timestamp_utc)) tsSet[d.properties.timestamp_utc] = 1;
  });
  PARA_DATA.forEach(function (d) {
    if (Number.isInteger(d.properties.timestamp_utc)) tsSet[d.properties.timestamp_utc] = 1;
  });
  var allTsSorted = Object.keys(tsSet).map(Number).sort(function (a, b) { return a - b; });

  var timeline = [];
  if (allTsSorted.length > 0) {
    for (var ti = 0; ti < allTsSorted.length; ti += TIMELINE_STEP) {
      timeline.push(allTsSorted[ti]);
    }
    if (timeline[timeline.length - 1] !== allTsSorted[allTsSorted.length - 1]) {
      timeline.push(allTsSorted[allTsSorted.length - 1]);
    }
  }

  var firstTs = timeline[0];

  function lastIndexBeforeTs(data, ts) {
    var lo = 0, hi = data.length - 1, result = -1;
    while (lo <= hi) {
      var mid = (lo + hi) >> 1;
      if (data[mid].properties.timestamp_utc <= ts) { result = mid; lo = mid + 1; }
      else hi = mid - 1;
    }
    return result;
  }

  /* === MAP === */
  var map = new mapboxgl.Map({
    container: 'map',
    style: 'mapbox://styles/mapbox/satellite-streets-v12',
    center: [-83.23, 42.57],
    zoom: 10, pitch: 45, bearing: 0, maxPitch: 85,
    projection: { name: 'mercator' },
    minZoom: 3
  });

  map.on('style.load', function () {
    map.setProjection('mercator');
    if (!map.getSource('mapbox-dem')) {
      map.addSource('mapbox-dem', {
        type: 'raster-dem', url: 'mapbox://mapbox.mapbox-terrain-dem-v1',
        tileSize: 512, maxzoom: 14
      });
    }
    map.setTerrain({ source: 'mapbox-dem', exaggeration: TERRAIN_EX });
  });

  var overlay = new MapboxOverlay({ interleaved: true, layers: [] });
  map.addControl(overlay);

  var allPts = HELI_DATA.concat(PARA_DATA);
  if (allPts.length) {
    var lngs = allPts.map(function (d) { return d.position[0]; });
    var lats = allPts.map(function (d) { return d.position[1]; });
    map.fitBounds(
      [[Math.min.apply(null, lngs), Math.min.apply(null, lats)],
       [Math.max.apply(null, lngs), Math.max.apply(null, lats)]],
      { padding: 60, duration: 0 }
    );
  }

  /* === RENDERING === */
  var slider = document.getElementById('timeSlider');
  var timeLabel = document.getElementById('timeLabel');
  var elapsedLabel = document.getElementById('elapsed');

  slider.min = 0;
  slider.max = timeline.length - 1;
  slider.value = 0;

  function fmtDuration(sec) {
    var h = Math.floor(sec / 3600);
    var m = Math.floor((sec % 3600) / 60);
    var s = sec % 60;
    return (h < 10 ? '0' : '') + h + ':' +
           (m < 10 ? '0' : '') + m + ':' +
           (s < 10 ? '0' : '') + s;
  }

  function fmtTime(ts) {
    return new Date(ts * 1000).toLocaleTimeString('en-US', {
      hour: '2-digit', minute: '2-digit', second: '2-digit', hour12: true
    });
  }

  function updateSliderTrack() {
    var pct = ((+slider.value - +slider.min) / (+slider.max - +slider.min)) * 100;
    slider.style.background =
      'linear-gradient(90deg, var(--accent) ' + pct + '%, rgba(255,255,255,0.1) ' + pct + '%)';
  }

  function buildPath(data, endIdx) {
    if (endIdx < 0) return [];
    var coords = [];
    for (var i = 0; i <= endIdx; i++) {
      var p = data[i].position;
      coords.push([p[0], p[1], (p[2] || 0) * TERRAIN_EX]);
    }
    return coords;
  }

  var lastHeliIdx = -1, lastParaIdx = -1;

  function renderAtIndex(idx) {
    var i = Math.max(0, Math.min(timeline.length - 1, idx | 0));
    var cutoffTs = timeline[i];
    var heliEnd = lastIndexBeforeTs(HELI_DATA, cutoffTs);
    var paraEnd = lastIndexBeforeTs(PARA_DATA, cutoffTs);

    lastHeliIdx = heliEnd;
    lastParaIdx = paraEnd;

    var layers = [];

    if (heliEnd >= 1) {
      layers.push(new PathLayer({
        id: 'heli-path',
        data: [{ path: buildPath(HELI_DATA, heliEnd) }],
        getPath: function (d) { return d.path; },
        getColor: [255, 140, 0, 200],
        widthMinPixels: 3, widthMaxPixels: 4,
        jointRounded: true, capRounded: true, billboard: false
      }));
    }

    if (paraEnd >= 1) {
      layers.push(new PathLayer({
        id: 'para-path',
        data: [{ path: buildPath(PARA_DATA, paraEnd) }],
        getPath: function (d) { return d.path; },
        getColor: [0, 206, 209, 200],
        widthMinPixels: 3, widthMaxPixels: 4,
        jointRounded: true, capRounded: true, billboard: false
      }));
    }

    var markers = [];
    if (heliEnd >= 0) {
      var hp = HELI_DATA[heliEnd].position;
      markers.push({
        position: [hp[0], hp[1], (hp[2] || 0) * TERRAIN_EX],
        fillColor: [255, 140, 0, 255], lineColor: [255, 255, 255, 255],
        radius: 14, isHeli: true
      });
    }
    if (paraEnd >= 0) {
      var pp = PARA_DATA[paraEnd].position;
      markers.push({
        position: [pp[0], pp[1], (pp[2] || 0) * TERRAIN_EX],
        fillColor: [0, 206, 209, 255], lineColor: [255, 255, 255, 255],
        radius: 14, isHeli: false
      });
    }
    if (markers.length) {
      layers.push(new ScatterplotLayer({
        id: 'markers',
        data: markers,
        getPosition: function (d) { return d.position; },
        getFillColor: function (d) { return d.fillColor; },
        getLineColor: function (d) { return d.lineColor; },
        getRadius: function (d) { return d.radius; },
        radiusUnits: 'pixels', stroked: true,
        lineWidthMinPixels: 2, pickable: true
      }));
    }

    overlay.setProps({ layers: layers });

    var elapsed = cutoffTs - firstTs;
    elapsedLabel.textContent = fmtDuration(elapsed);
    timeLabel.textContent = fmtTime(cutoffTs);
    updateSliderTrack();
    updateStats(heliEnd, paraEnd);
    drawAltChart(cutoffTs);
  }

  /* === STATS PANEL === */
  var statsBody = document.getElementById('statsBody');
  var statsToggle = document.getElementById('statsToggle');
  var statsPanel = document.getElementById('stats');
  statsToggle.addEventListener('click', function () {
    statsPanel.classList.toggle('collapsed');
  });

  function calcSpeed(data, idx) {
    if (idx < 1) return 0;
    var a = data[idx - 1], b = data[idx];
    var dt = (b.properties.timestamp_utc - a.properties.timestamp_utc) || 1;
    return (haversine(a.position, b.position) / dt) * 3600;
  }

  var paraMaxAltUpTo = [];
  if (PARA_DATA.length) {
    paraMaxAltUpTo[0] = PARA_DATA[0].position[2];
    for (var pi = 1; pi < PARA_DATA.length; pi++) {
      paraMaxAltUpTo[pi] = Math.max(paraMaxAltUpTo[pi - 1], PARA_DATA[pi].position[2]);
    }
  }

  function updateStats(heliEnd, paraEnd) {
    var html = '';

    html += '<div class="stat-section">';
    html += '<div class="stat-label"><span class="dot" style="background:var(--heli-color)"></span>Helicopter</div>';
    if (heliEnd >= 0) {
      var hd = HELI_DATA[heliEnd];
      var hAlt = hd.properties.altitude_ft != null
        ? hd.properties.altitude_ft : Math.round(hd.position[2] * M_TO_FT);
      var hMax = Math.round(heliMaxZ * M_TO_FT);
      var hDist = heliCumDist[heliEnd];
      var hSpeed = hd.properties.speed_kt != null ? hd.properties.speed_kt + ' kt' : '\u2014';
      var hDur = hd.properties.timestamp_utc - HELI_DATA[0].properties.timestamp_utc;
      html += '<div class="stat-row"><span>Altitude</span><span class="val">' + hAlt.toLocaleString() + ' ft</span></div>';
      html += '<div class="stat-row"><span>Max Alt</span><span class="val">' + hMax.toLocaleString() + ' ft</span></div>';
      html += '<div class="stat-row"><span>Distance</span><span class="val">' + hDist.toFixed(1) + ' mi</span></div>';
      html += '<div class="stat-row"><span>Speed</span><span class="val">' + hSpeed + '</span></div>';
      html += '<div class="stat-row"><span>Duration</span><span class="val">' + fmtDuration(hDur) + '</span></div>';
    } else {
      html += '<div style="color:var(--text-dim)">Not yet active</div>';
    }
    html += '</div>';

    html += '<div class="stat-section">';
    html += '<div class="stat-label"><span class="dot" style="background:var(--para-color)"></span>Paraglider</div>';
    if (paraEnd >= 0) {
      var pd = PARA_DATA[paraEnd];
      var pAlt = pd.properties.altitude_ft != null
        ? pd.properties.altitude_ft : Math.round(pd.position[2] * M_TO_FT);
      var pMax = Math.round(paraMaxAltUpTo[paraEnd] * M_TO_FT);
      var pDist = paraCumDist[paraEnd];
      var pSpeed = calcSpeed(PARA_DATA, paraEnd).toFixed(1) + ' mph';
      var pDur = pd.properties.timestamp_utc - PARA_DATA[0].properties.timestamp_utc;
      html += '<div class="stat-row"><span>Altitude</span><span class="val">' + pAlt.toLocaleString() + ' ft</span></div>';
      html += '<div class="stat-row"><span>Max Alt</span><span class="val">' + pMax.toLocaleString() + ' ft</span></div>';
      html += '<div class="stat-row"><span>Distance</span><span class="val">' + pDist.toFixed(1) + ' mi</span></div>';
      html += '<div class="stat-row"><span>Speed</span><span class="val">' + pSpeed + '</span></div>';
      html += '<div class="stat-row"><span>Duration</span><span class="val">' + fmtDuration(pDur) + '</span></div>';
    } else {
      html += '<div style="color:var(--text-dim)">Not yet active</div>';
    }
    html += '</div>';

    if (heliEnd >= 0 && paraEnd >= 0) {
      var dist = haversine(HELI_DATA[heliEnd].position, PARA_DATA[paraEnd].position);
      html += '<div class="stat-shared">';
      html += '<div class="stat-row"><span>Distance Apart</span><span class="val">' + dist.toFixed(1) + ' mi</span></div>';
      html += '</div>';
    }

    statsBody.innerHTML = html;
  }

  /* === ALTITUDE CHART === */
  var altCanvas = document.getElementById('altCanvas');
  var altCtx = altCanvas.getContext('2d');

  var heliChartTs = HELI_DATA.map(function (d) { return d.properties.timestamp_utc; });
  var heliChartAlt = HELI_DATA.map(function (d) { return (d.position[2] || 0) * M_TO_FT; });
  var paraChartTs = PARA_DATA.map(function (d) { return d.properties.timestamp_utc; });
  var paraChartAlt = PARA_DATA.map(function (d) { return (d.position[2] || 0) * M_TO_FT; });

  var chartMinTs = timeline[0];
  var chartMaxTs = timeline[timeline.length - 1];
  var allAlts = heliChartAlt.concat(paraChartAlt);
  var chartMinAlt = Math.min.apply(null, allAlts);
  var chartMaxAlt = Math.max.apply(null, allAlts);

  function drawAltChart(currentTs) {
    var dpr = window.devicePixelRatio || 1;
    var rect = altCanvas.parentElement.getBoundingClientRect();
    var w = rect.width, h = rect.height;
    altCanvas.width = w * dpr;
    altCanvas.height = h * dpr;
    altCanvas.style.width = w + 'px';
    altCanvas.style.height = h + 'px';
    altCtx.setTransform(dpr, 0, 0, dpr, 0, 0);

    var pad = { top: 12, right: 16, bottom: 22, left: 48 };
    var cw = w - pad.left - pad.right;
    var ch = h - pad.top - pad.bottom;
    var altRange = chartMaxAlt - chartMinAlt || 1;
    var tsRange = chartMaxTs - chartMinTs || 1;

    altCtx.clearRect(0, 0, w, h);

    altCtx.strokeStyle = 'rgba(255,255,255,0.06)';
    altCtx.lineWidth = 1;
    altCtx.fillStyle = 'rgba(255,255,255,0.35)';
    altCtx.font = '10px system-ui';
    altCtx.textAlign = 'right';
    var nTicks = 4;
    for (var t = 0; t <= nTicks; t++) {
      var alt = chartMinAlt + (altRange * t / nTicks);
      var yy = pad.top + ch - (ch * t / nTicks);
      altCtx.beginPath();
      altCtx.moveTo(pad.left, yy);
      altCtx.lineTo(w - pad.right, yy);
      altCtx.stroke();
      altCtx.fillText(Math.round(alt).toLocaleString() + ' ft', pad.left - 4, yy + 3);
    }

    function tsToX(ts) { return pad.left + ((ts - chartMinTs) / tsRange) * cw; }
    function altToY(a) { return pad.top + ch - ((a - chartMinAlt) / altRange) * ch; }

    if (heliChartTs.length > 1) {
      altCtx.beginPath();
      altCtx.strokeStyle = 'rgba(255,140,0,0.8)';
      altCtx.lineWidth = 1.5;
      for (var ci = 0; ci < heliChartTs.length; ci++) {
        ci === 0 ? altCtx.moveTo(tsToX(heliChartTs[ci]), altToY(heliChartAlt[ci]))
                 : altCtx.lineTo(tsToX(heliChartTs[ci]), altToY(heliChartAlt[ci]));
      }
      altCtx.stroke();
    }

    if (paraChartTs.length > 1) {
      altCtx.beginPath();
      altCtx.strokeStyle = 'rgba(0,206,209,0.8)';
      altCtx.lineWidth = 1.5;
      for (var j = 0; j < paraChartTs.length; j += PARA_CHART_STEP) {
        j === 0 ? altCtx.moveTo(tsToX(paraChartTs[j]), altToY(paraChartAlt[j]))
                : altCtx.lineTo(tsToX(paraChartTs[j]), altToY(paraChartAlt[j]));
      }
      var li = paraChartTs.length - 1;
      altCtx.lineTo(tsToX(paraChartTs[li]), altToY(paraChartAlt[li]));
      altCtx.stroke();
    }

    var cx = tsToX(currentTs);
    altCtx.strokeStyle = 'rgba(255,255,255,0.6)';
    altCtx.lineWidth = 1;
    altCtx.setLineDash([4, 3]);
    altCtx.beginPath();
    altCtx.moveTo(cx, pad.top);
    altCtx.lineTo(cx, pad.top + ch);
    altCtx.stroke();
    altCtx.setLineDash([]);
  }

  /* === PLAYBACK === */
  var playBtn = document.getElementById('playBtn');
  var playing = false;
  var raf = 0;
  var lastFrameTime = 0;
  var playSpeed = 1;
  // Base interval between animation frames in ms; lower = faster default playback
  var BASE_STEP_MS = 100;

  slider.addEventListener('input', function () {
    if (playing) stopPlayback();
    renderAtIndex(+slider.value);
  });

  function stepAnimation(t) {
    if (!playing) return;
    var interval = BASE_STEP_MS / playSpeed;
    if (t - lastFrameTime >= interval) {
      var idx = +slider.value;
      if (idx < +slider.max) {
        idx++;
        slider.value = idx;
        renderAtIndex(idx);
      } else {
        stopPlayback();
        return;
      }
      lastFrameTime = t;
    }
    raf = requestAnimationFrame(stepAnimation);
  }

  function startPlayback() {
    playing = true;
    playBtn.innerHTML = '&#9646;&#9646;';
    playBtn.title = 'Pause';
    lastFrameTime = 0;
    raf = requestAnimationFrame(stepAnimation);
  }

  function stopPlayback() {
    playing = false;
    playBtn.innerHTML = '&#9654;';
    playBtn.title = 'Play';
    cancelAnimationFrame(raf);
  }

  playBtn.addEventListener('click', function () {
    if (playing) { stopPlayback(); }
    else {
      if (+slider.value >= +slider.max) slider.value = 0;
      startPlayback();
    }
  });

  document.querySelectorAll('.speed-btn').forEach(function (btn) {
    btn.addEventListener('click', function () {
      document.querySelectorAll('.speed-btn').forEach(function (b) {
        b.classList.remove('active');
      });
      btn.classList.add('active');
      playSpeed = +btn.getAttribute('data-speed');
    });
  });

  window.addEventListener('beforeunload', function () {
    playing = false;
    cancelAnimationFrame(raf);
  });

  /* === CLICK TO INSPECT === */
  map.on('click', function (e) {
    var x = e.point.x, y = e.point.y;
    var pickFn = overlay.pickObject
      ? overlay.pickObject.bind(overlay)
      : (overlay._deck ? overlay._deck.pickObject.bind(overlay._deck) : null);
    if (!pickFn) return;
    var pick = pickFn({
      x: x, y: y, radius: 16,
      layerIds: ['heli-path', 'para-path', 'markers']
    });
    if (!pick || !pick.object) return;

    var info = {};
    var obj = pick.object;
    if (obj.isHeli === true && lastHeliIdx >= 0) {
      info = HELI_DATA[lastHeliIdx].properties;
    } else if (obj.isHeli === false && lastParaIdx >= 0) {
      info = PARA_DATA[lastParaIdx].properties;
    }

    var p = info;
    var popupHtml = '<div>' +
      '<div><b>Altitude:</b> ' +
        (p.altitude_ft != null ? p.altitude_ft + ' ft' : '\u2014') + '</div>' +
      '<div><b>Speed:</b> ' +
        (p.speed_kt != null ? p.speed_kt + ' kt' : '\u2014') + '</div>' +
      '<div><b>Heading:</b> ' +
        (p.heading_deg != null ? p.heading_deg + '\u00B0' : '\u2014') + '</div>' +
      '<div><b>Time:</b> ' +
        (p.timestamp_local ? p.timestamp_local
          : (Number.isInteger(p.timestamp_utc)
              ? new Date(p.timestamp_utc * 1000).toLocaleString() : '\u2014')) + '</div>' +
      '<div><b>Coords:</b> ' +
        e.lngLat.lng.toFixed(5) + ', ' + e.lngLat.lat.toFixed(5) + '</div>' +
      '</div>';

    new mapboxgl.Popup({ closeButton: true, closeOnClick: true })
      .setLngLat([e.lngLat.lng, e.lngLat.lat])
      .setHTML(popupHtml)
      .addTo(map);
  });

  window.addEventListener('resize', function () {
    drawAltChart(timeline[+slider.value] || firstTs);
  });

  renderAtIndex(0);
  map.getCanvas().addEventListener('contextmenu', function (e) { e.preventDefault(); });

})();
</script>
</body>
</html>