<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>jdog</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    html, body, #map { margin: 0; height: 100%; width: 100%; }
    .mapboxgl-popup, .mapboxgl-popup-content { z-index: 10000 !important; pointer-events: auto; }
    #ui {
    position: absolute; top: 10px; left: 10px; z-index: 10001;
    background: rgba(255,255,255,0.9); padding: 8px 10px; border-radius: 6px;
    font: 12px/1.3 system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial,sans-serif;
    display: inline-flex; align-items: center; gap: 8px;
  }
  #ui input[type="range"] { width: 260px; }
  #ui .label { min-width: 160px; }
  #ui button { padding: 4px 8px; }
  
  </style>

  <!-- Libraries (load Mapbox GL first, then deck.gl) -->
  <script src="https://api.mapbox.com/mapbox-gl-js/v3.2.0/mapbox-gl.js"></script>
  <link href="https://api.mapbox.com/mapbox-gl-js/v3.2.0/mapbox-gl.css" rel="stylesheet" />
  <script src="https://unpkg.com/deck.gl@^9.0.0/dist.min.js"></script>
  <script src="data.js"></script> <!-- your GEOJSON data as a variable named GEOJSON -->
</head>
<body>
<div id="map"></div>
<div id="ui">
  <button id="startBtn" type="button">Start</button>
  <button id="stopBtn"  type="button" disabled>Stop</button>
  <input type="range" id="timeSlider" min="1" max="1" step="1" value="1" />
  <span class="label" id="timeLabel"></span>
</div>


<script type="text/javascript">
  // Replace with a valid public token (pk.*) with styles:read + tilesets:read
  mapboxgl.accessToken = 'pk.eyJ1Ijoicm91c2hqYWMiLCJhIjoiY2xsZ205dnk2MTBmNzNucXZydmJzNGZycSJ9.QH9OthOUQTvlv-gDh3Q6mw';

const POINT_SIZE = 8;

  // Flatten features
  const HELI_DATA = (HELI_GEOJSON.features || [])
    .filter(f => f && f.geometry && f.geometry.type === 'Point' && Array.isArray(f.geometry.coordinates))
    .map(f => ({
      position: f.geometry.coordinates,   // [lng, lat, zMeters]
      properties: f.properties || {}
    }));

  const PARA_DATA = (PARA_GEOJSON.features || [])
    .filter(f => f && f.geometry && f.geometry.type === 'Point' && Array.isArray(f.geometry.coordinates))
    .map(f => ({
      position: f.geometry.coordinates,   // [lng, lat, zMeters]
      properties: f.properties || {}
    }));

  // Mapbox map
  const center = HELI_DATA.length ? [HELI_DATA[0].position[0], HELI_DATA[0].position[1]] : [-83.0458, 42.3314];
const map = new mapboxgl.Map({
  container: 'map',
  style: 'mapbox://styles/mapbox/satellite-streets-v12',
  center, zoom: 11, pitch: 60, bearing: 20, maxPitch: 85,
  projection: {name: 'mercator'},    // <- prevent globe switch
  minZoom: 3                         
});

    map.on('style.load', () => {
    map.setProjection('mercator');      // <- enforce mercator if style tries to change it
    if (!map.getSource('mapbox-dem')) {
        map.addSource('mapbox-dem', {
        type: 'raster-dem',
        url: 'mapbox://mapbox.mapbox-terrain-dem-v1',
        tileSize: 512,
        maxzoom: 14
        });
    }
    map.setTerrain({source: 'mapbox-dem', exaggeration: TERRAIN_EXAGGERATION});
    // map.setFog({color:'white','high-color':'#c6e7ff','horizon-blend':0.2,'space-color':'#000','star-intensity':0});
    });

  // === Overlay and slider-driven rendering ===
const {PointCloudLayer, COORDINATE_SYSTEM, MapboxOverlay} = deck;
const TERRAIN_EXAGGERATION = 3.0; // keep in sync with map.setTerrain
const overlay = new MapboxOverlay({ interleaved: true, layers: [] });
map.addControl(overlay);

const elevations = HELI_DATA.map(d => d.position[2] || 0);
const minZ = Math.min(...elevations);
const maxZ = Math.max(...elevations);

// Orange → Purple
const COLOR_LOW = [255, 140, 0];
const COLOR_HIGH = [128, 0, 128];

// Helper: interpolate between two RGB colors
function lerpColor(c1, c2, t) {
  return [
    Math.round(c1[0] + (c2[0] - c1[0]) * t),
    Math.round(c1[1] + (c2[1] - c1[1]) * t),
    Math.round(c1[2] + (c2[2] - c1[2]) * t),
    255
  ];
}

// Slider wiring
const slider = document.getElementById('timeSlider');
const label  = document.getElementById('timeLabel');
slider.max = Math.max(1, HELI_DATA.length);
slider.value = 1;

// Keep currently selected popup in sync with filtering
let selected = null; // {lng,lat,z,properties} if you use the custom DOM popup from earlier

function renderUpTo(count) {
  const n = Math.max(1, Math.min(HELI_DATA.length, count|0));
  const subset = HELI_DATA.slice(0, n);

  const layer = new PointCloudLayer({
    id: 'points-3d',
    data: subset,
    pickable: true,
    coordinateSystem: COORDINATE_SYSTEM.LNGLAT,
    positionFormat: 'XYZ',
    getPosition: d => [d.position[0], d.position[1], d.position[2] * TERRAIN_EXAGGERATION],
    getColor: d => {
    const z = d.position[2];
    const t = (z - minZ) / (maxZ - minZ || 1);
    return lerpColor(COLOR_LOW, COLOR_HIGH, t);
  },
    pointSize: 12,
    parameters: {
      // If terrain can occlude points and you want them always visible, uncomment:
      // depthTest: false
    },
    updateTriggers: {
      // only recompute color when z or min/max change
      getColor: [minZ, maxZ]
    }
  });

  overlay.setProps({ layers: [layer] });

  // Label shows index and timestamp of the newest visible point
  const ts = subset[n - 1]?.properties?.timestamp_local || '';
  label.textContent = `${n}/${HELI_DATA.length}  ${ts}`;

  // If you used the custom DOM popup: hide it if it refers to a filtered-out point
  if (selected) {
    const idx = HELI_DATA.indexOf(HELI_DATA.find(d =>
      d.properties === selected.properties ||
      (d.position[0] === selected.lng && d.position[1] === selected.lat && d.position[2]*TERRAIN_EXAGGERATION === selected.z)
    ));
    if (idx >= n || idx === -1) {
      selected = null;
      const el = document.querySelector('#ui-popup'); // your popup element id if used
      if (el) el.style.display = 'none';
    }
  }
}

// Slider input -> re-render
slider.addEventListener('input', e => renderUpTo(+e.target.value));

// Initial draw (start at first point)
renderUpTo(+slider.value);

const startBtn = document.getElementById('startBtn');
const stopBtn  = document.getElementById('stopBtn');

// Animation cadence (ms per step)
const STEP_MS = 300;

let playing = false;
let raf = 0;
let last = 0;

function step(t) {
  if (!playing) return;
  if (t - last >= STEP_MS) {
    let idx = +slider.value;
    idx = (idx < HELI_DATA.length) ? (idx + 1) : 1; // loop
    slider.value = idx;
    renderUpTo(idx);
    last = t;
  }
  raf = requestAnimationFrame(step);
}

startBtn.addEventListener('click', () => {
  if (playing) return;
  playing = true;
  startBtn.disabled = true;
  stopBtn.disabled = false;
  last = 0;
  raf = requestAnimationFrame(step);
});

stopBtn.addEventListener('click', () => {
  if (!playing) return;
  playing = false;
  startBtn.disabled = false;
  stopBtn.disabled = true;
  cancelAnimationFrame(raf);
});

// Stop animation if user manually drags the slider
slider.addEventListener('input', () => {
  if (playing) {
    playing = false;
    startBtn.disabled = false;
    stopBtn.disabled = true;
    cancelAnimationFrame(raf);
  }
  renderUpTo(+slider.value);
});

// Cleanup on page unload
window.addEventListener('beforeunload', () => {
  playing = false;
  cancelAnimationFrame(raf);
});

  // Use Mapbox click -> Deck picking
  map.on('click', (e) => {
    const {x, y} = e.point; // pixel coords relative to map canvas
    // Prefer overlay.pickObject; fall back to underlying Deck if needed
    const pick = (overlay.pickObject ? overlay.pickObject({x, y, radius: POINT_SIZE, layerIds: ['points-3d']})
                                     : overlay._deck && overlay._deck.pickObject({x, y, radius: POINT_SIZE, layerIds: ['points-3d']}));
    if (!pick || !pick.object) return;

    const p = pick.object.properties || {};
    const html = `
      <div style="font:12px/1.35 system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial,sans-serif;">
        <div><b>Altitude (ft):</b> ${p.altitude_ft ?? '—'}</div>
        <div><b>Speed (kt):</b> ${p.speed_kt ?? '—'}</div>
        <div><b>Heading (°):</b> ${p.heading_deg ?? '—'}</div>
        <div><b>Timestamp:</b> ${p.timestamp_local ?? '—'}</div>
        <div><b>Coordinates:</b> ${pick.coordinate.map(v => v.toFixed(5)).join(', ')}</div>
      </div>`;

    new mapboxgl.Popup({closeButton: true, closeOnClick: true})
      .setLngLat([e.lngLat.lng, e.lngLat.lat])   // 2D coords for popup
      .setHTML(html)
      .addTo(map);
  });

  // Fit to data bounds
  if (HELI_DATA.length > 0) {
    const lngs = HELI_DATA.map(d => d.position[0]);
    const lats = HELI_DATA.map(d => d.position[1]);
    const bounds = new mapboxgl.LngLatBounds(
      [Math.min(...lngs), Math.min(...lats)],
      [Math.max(...lngs), Math.max(...lats)]
    );
    map.fitBounds(bounds, {padding: 60, duration: 0});
    map.setPitch(20);
    map.setBearing(0);
  }

  // Right-click rotate usability
  map.getCanvas().addEventListener('contextmenu', e => e.preventDefault());
</script>
</body>
</html>
