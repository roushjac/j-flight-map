<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>jdog</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    html, body, #map { margin: 0; height: 100%; width: 100%; }
    .mapboxgl-popup, .mapboxgl-popup-content { z-index: 10000 !important; pointer-events: auto; }
    #ui {
      position: absolute; top: 10px; left: 10px; z-index: 10001;
      background: rgba(255,255,255,0.9); padding: 8px 10px; border-radius: 6px;
      font: 12px/1.3 system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial,sans-serif;
      display: inline-flex; align-items: center; gap: 8px;
    }
    #ui input[type="range"] { width: 260px; }
    #ui .label { min-width: 260px; }
    #ui button { padding: 4px 8px; }
  </style>

  <script src="https://api.mapbox.com/mapbox-gl-js/v3.2.0/mapbox-gl.js"></script>
  <link href="https://api.mapbox.com/mapbox-gl-js/v3.2.0/mapbox-gl.css" rel="stylesheet" />
  <script src="https://unpkg.com/deck.gl@^9.0.0/dist.min.js"></script>
  <script src="data.js"></script> <!-- must define HELI_GEOJSON and PARA_GEOJSON -->
</head>
<body>
<div id="map"></div>
<div id="ui">
  <button id="startBtn" type="button">Start</button>
  <button id="stopBtn"  type="button" disabled>Stop</button>
  <input type="range" id="timeSlider" min="0" max="0" step="1" value="0" />
  <span class="label" id="timeLabel"></span>
</div>

<script type="text/javascript">
  mapboxgl.accessToken = 'pk.eyJ1Ijoicm91c2hqYWMiLCJhIjoiY2xsZ205dnk2MTBmNzNucXZydmJzNGZycSJ9.QH9OthOUQTvlv-gDh3Q6mw';

  const {PointCloudLayer, COORDINATE_SYSTEM, MapboxOverlay} = deck;
  const TERRAIN_EXAGGERATION = 3.0;
  const POINT_SIZE = 8;

  function parseTs(v) {
    if (v === null || v === undefined) return null;
    if (typeof v === 'string') v = v.trim();
    if (typeof v === 'string' && /[A-Za-z:-]/.test(v)) {
      const ms = Date.parse(v);
      return Number.isFinite(ms) ? Math.round(ms / 1000) : null;
    }
    const n = Number(v);
    if (!Number.isFinite(n)) return null;
    return Math.abs(n) >= 1e12 ? Math.round(n / 1000) : Math.trunc(n);
  }

  function normFeature(f) {
    const coords = f.geometry.coordinates;
    const z = (coords.length >= 3 && Number.isFinite(+coords[2])) ? +coords[2] : 0;
    const props = Object.assign({}, f.properties || {});
    const ts = parseTs(props.timestamp_utc);
    if (ts !== null) props.timestamp_utc = ts; else delete props.timestamp_utc;
    if (!props.timestamp_local && ts !== null) props.timestamp_local = new Date(ts * 1000).toLocaleString();
    return { position: [ +coords[0], +coords[1], z ], properties: props };
  }

  const HELI_DATA = (HELI_GEOJSON.features || [])
    .filter(f => f && f.geometry && f.geometry.type === 'Point' && Array.isArray(f.geometry.coordinates))
    .map(normFeature);

  const PARA_DATA = (PARA_GEOJSON.features || [])
    .filter(f => f && f.geometry && f.geometry.type === 'Point' && Array.isArray(f.geometry.coordinates))
    .map(normFeature)
    .map(f => {
      f.properties.altitude_ft = Math.floor(f.position[2] * 3.28084); // meters to feet
      return f;
    });

  const FALLBACK_CENTER = [-83.0458, 42.3314];
  const first = HELI_DATA[0] || PARA_DATA[0];
  const center = first ? [first.position[0], first.position[1]] : FALLBACK_CENTER;

  const map = new mapboxgl.Map({
    container: 'map',
    style: 'mapbox://styles/mapbox/satellite-streets-v12',
    center, zoom: 11, pitch: 60, bearing: 20, maxPitch: 85,
    projection: {name: 'mercator'},
    minZoom: 3
  });

  map.on('style.load', () => {
    map.setProjection('mercator');
    if (!map.getSource('mapbox-dem')) {
      map.addSource('mapbox-dem', {
        type: 'raster-dem',
        url: 'mapbox://mapbox.mapbox-terrain-dem-v1',
        tileSize: 512,
        maxzoom: 14
      });
    }
    map.setTerrain({source: 'mapbox-dem', exaggeration: TERRAIN_EXAGGERATION});
  });

  const overlay = new MapboxOverlay({ interleaved: true, layers: [] });
  map.addControl(overlay);

  // Independent color domains and schemes per dataset
  const elevHeli = HELI_DATA.map(d => d.position[2] || 0);
  const minZHeli = elevHeli.length ? Math.min(...elevHeli) : 0;
  const maxZHeli = elevHeli.length ? Math.max(...elevHeli) : 1;

  const elevPara = PARA_DATA.map(d => d.position[2] || 0);
  const minZPara = elevPara.length ? Math.min(...elevPara) : 0;
  const maxZPara = elevPara.length ? Math.max(...elevPara) : 1;

  // PARA: Cyan → Red (distinct scheme)
  const COLOR_LOW  = [  0, 200, 255];
  const COLOR_HIGH = [220,   0,  60];

  function lerpColor(c1, c2, t) {
    const u = Math.max(0, Math.min(1, t));
    return [
      Math.round(c1[0] + (c2[0] - c1[0]) * u),
      Math.round(c1[1] + (c2[1] - c1[1]) * u),
      Math.round(c1[2] + (c2[2] - c1[2]) * u),
      255
    ];
  }
  function colorForZHeli(z) {
    const t = (z - minZHeli) / (maxZHeli - minZHeli || 1);
    return lerpColor(COLOR_LOW, COLOR_HIGH, t);
  }
  function colorForZPara(z) {
    const t = (z - minZPara) / (maxZPara - minZPara || 1);
    return lerpColor(COLOR_LOW, COLOR_HIGH, t);
  }

  // Timeline from valid UTC seconds across both datasets
  const allTimestamps = Array.from(new Set(
    HELI_DATA.map(d => d.properties.timestamp_utc).concat(PARA_DATA.map(d => d.properties.timestamp_utc))
  )).filter(v => Number.isInteger(v)).sort((a,b)=>a-b);

  const timelineMode = allTimestamps.length > 0;

  const slider = document.getElementById('timeSlider');
  const label  = document.getElementById('timeLabel');

  if (timelineMode) {
    slider.min = 0;
    slider.max = allTimestamps.length - 1;
    slider.step = 1;
    slider.value = 0;
  } else {
    slider.min = 0; slider.max = 0; slider.value = 0;
  }

  function renderAtIndex(idx) {
    let heliSub = HELI_DATA;
    let paraSub = PARA_DATA;
    let tsLabel = '';

    if (timelineMode) {
      const i = Math.max(0, Math.min(allTimestamps.length - 1, idx|0));
      const cutoffTs = allTimestamps[i];
      heliSub = HELI_DATA.filter(d => Number.isInteger(d.properties.timestamp_utc) && d.properties.timestamp_utc <= cutoffTs);
      paraSub = PARA_DATA.filter(d => Number.isInteger(d.properties.timestamp_utc) && d.properties.timestamp_utc <= cutoffTs);
      tsLabel = `${i+1}/${allTimestamps.length}  ${new Date(cutoffTs * 1000).toLocaleString()}  (utc:${cutoffTs})`;
    } else {
      tsLabel = `All points (timestamps missing/invalid)`;
    }

    const heliLayer = new PointCloudLayer({
      id: 'heli-3d',
      data: heliSub,
      pickable: true,
      coordinateSystem: COORDINATE_SYSTEM.LNGLAT,
      positionFormat: 'XYZ',
      getPosition: d => [d.position[0], d.position[1], (d.position[2]||0) * TERRAIN_EXAGGERATION],
      getColor: d => colorForZHeli(d.position[2]||0),
      pointSize: 12,
      updateTriggers: { getColor: [minZHeli, maxZHeli] }
    });

    const paraLayer = new PointCloudLayer({
      id: 'para-3d',
      data: paraSub,
      pickable: true,
      coordinateSystem: COORDINATE_SYSTEM.LNGLAT,
      positionFormat: 'XYZ',
      getPosition: d => [d.position[0], d.position[1], (d.position[2]||0) * TERRAIN_EXAGGERATION],
      getColor: d => colorForZPara(d.position[2]||0),
      pointSize: 12,
      updateTriggers: { getColor: [minZPara, maxZPara] }
    });

    overlay.setProps({ layers: [heliLayer, paraLayer] });
    label.textContent = tsLabel;
  }

  renderAtIndex(+slider.value);

  slider.addEventListener('input', e => {
    renderAtIndex(+e.target.value);
  });

  const startBtn = document.getElementById('startBtn');
  const stopBtn  = document.getElementById('stopBtn');
  const STEP_MS = 300;
  let playing = false;
  let raf = 0;
  let last = 0;

  function step(t) {
    if (!playing) return;
    if (t - last >= STEP_MS) {
      let idx = +slider.value;
      const maxIdx = +slider.max;
      idx = (idx < maxIdx) ? (idx + 1) : 0;
      slider.value = idx;
      renderAtIndex(idx);
      last = t;
    }
    raf = requestAnimationFrame(step);
  }

  startBtn.addEventListener('click', () => {
    if (playing || !timelineMode) return;
    playing = true;
    startBtn.disabled = true;
    stopBtn.disabled = false;
    last = 0;
    raf = requestAnimationFrame(step);
  });

  stopBtn.addEventListener('click', () => {
    if (!playing) return;
    playing = false;
    startBtn.disabled = false;
    stopBtn.disabled = true;
    cancelAnimationFrame(raf);
  });

  slider.addEventListener('input', () => {
    if (playing) {
      playing = false;
      startBtn.disabled = false;
      stopBtn.disabled = true;
      cancelAnimationFrame(raf);
    }
  });

  window.addEventListener('beforeunload', () => {
    playing = false;
    cancelAnimationFrame(raf);
  });

  map.on('click', (e) => {
    const {x, y} = e.point;
    const pick = (overlay.pickObject ? overlay.pickObject({x, y, radius: POINT_SIZE, layerIds: ['heli-3d','para-3d']})
                                     : overlay._deck && overlay._deck.pickObject({x, y, radius: POINT_SIZE, layerIds: ['heli-3d','para-3d']}));
    if (!pick || !pick.object) return;

    const p = pick.object.properties || {};
    const html = `
      <div style="font:12px/1.35 system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial,sans-serif;">
        <div><b>Altitude (ft):</b> ${p.altitude_ft ?? '—'}</div>
        <div><b>Speed (kt):</b> ${p.speed_kt ?? '—'}</div>
        <div><b>Heading (°):</b> ${p.heading_deg ?? '—'}</div>
        <div><b>Timestamp:</b> ${p.timestamp_local ?? (Number.isInteger(p.timestamp_utc)? new Date(p.timestamp_utc*1000).toLocaleString() : '—')}</div>
        <div><b>UTC (s):</b> ${Number.isInteger(p.timestamp_utc) ? p.timestamp_utc : '—'}</div>
        <div><b>Coordinates:</b> ${pick.coordinate.map(v => v.toFixed(5)).join(', ')}</div>
      </div>`;

    new mapboxgl.Popup({closeButton: true, closeOnClick: true})
      .setLngLat([e.lngLat.lng, e.lngLat.lat])
      .setHTML(html)
      .addTo(map);
  });

  (function fitBounds() {
    const all = HELI_DATA.concat(PARA_DATA);
    if (!all.length) return;
    const lngs = all.map(d => d.position[0]);
    const lats = all.map(d => d.position[1]);
    const bounds = new mapboxgl.LngLatBounds(
      [Math.min(...lngs), Math.min(...lats)],
      [Math.max(...lngs), Math.max(...lats)]
    );
    map.fitBounds(bounds, {padding: 60, duration: 0});
    map.setPitch(20);
    map.setBearing(0);
  })();

  map.getCanvas().addEventListener('contextmenu', e => e.preventDefault());
</script>
</body>
</html>
